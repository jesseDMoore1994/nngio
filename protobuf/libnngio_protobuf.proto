syntax = "proto3";

package LibnngioProtobuf;

// Example usage:
// 1. A server defines its services and RPC methods using protobuf.
// 2. The server also implements the ServiceDiscoveryService to advertise its services.
// 3. A client connects to the server and calls GetServices to get the list of services.
// 4. The client can then construct RpcRequestMessage messages to call the desired RPC methods.
// 5. The server processes the RpcRequestMessage and responds with an RpcResponseMessage.
// 6. Both client and server can also use RawMessage for sending arbitrary binary data if needed.
// 7. The NngioMessage wrapper is used to encapsulate the different message types.

message Service {
    string name = 1; // Name of the service
    repeated string methods = 2; // List of RPC methods provided by the service
}

message ServiceDiscoveryRequest {
    // Empty message for requesting service discovery
}

message ServiceDiscoveryResponse {
    repeated Service services = 1; // List of available services
}

message RpcRequest {
    string service_name = 1; // Name of the service to call
    string method_name = 2; // Name of the method to call
    bytes payload = 3; // Serialized request payload
}

message RpcResponse {
    enum Status {
       Success = 0; // RPC call was successful
       ServiceNotFound = 1; // Service not found
       MethodNotFound = 2; // Method not found
       InvalidRequest = 3; // Request payload was invalid
       InternalError = 4; // Internal server error
    }
    Status status = 1; // Status of the RPC call
    bytes payload = 2; // Serialized response payload
    string error_message = 3; // Error message if the RPC call failed
}

message Raw {
    bytes data = 1; // Arbitrary binary data
}

message LibnngioMessage {
    oneof msg {
        ServiceDiscoveryRequest service_discovery_request = 1;
        ServiceDiscoveryResponse service_discovery_response = 2;
        RpcRequest rpc_request = 3;
        RpcResponse rpc_response = 4;
        Raw raw = 5;
    }
    string uuid = 6; // Unique identifier for the message
}

message LibnngioTransport {
    enum TransportMode {
        Dial = 0; // Client mode
        Listen = 1; // Server mode
    }
    enum TransportProtocol {
        Pair = 0; // Pair protocol
        Req = 1; // Request protocol
        Rep = 2; // Reply protocol
        Pub = 3; // Publish protocol
        Sub = 4; // Subscribe protocol
        Push = 5; // Push protocol
        Pull = 6; // Pull protocol
        Serveyor = 7; // Surveyor protocol
        Respondent = 8; // Respondent protocol
        Bus = 9; // Bus protocol
    }

    TransportMode mode = 1; // Mode of the transport
    TransportProtocol protocol = 2; // Protocol of the transport
    string address = 3; // Address to connect or bind to

    string tls_cert = 4; // TLS certificate for secure connections
    string tls_key = 5; // TLS private key for secure connections
    string tls_ca = 6; // TLS CA certificate for secure connections

    uint32 recv_timeout_ms = 7; // Receive timeout in milliseconds
    uint32 send_timeout_ms = 8; // Send timeout in milliseconds
    uint64 max_msg_size = 9; // Maximum message size in bytes
}

message TransportDiscoveryRequest {
    // Empty message for requesting service discovery
}

message TransportDiscoveryResponse {
    repeated LibnngioTransport transports = 1; // List of available transports
}

service RpcService {
    rpc CallRpc(RpcRequest) returns (RpcResponse);
}

service ServiceDiscoveryService {
    rpc GetServices(ServiceDiscoveryRequest) returns (ServiceDiscoveryResponse);
}

service TransportDiscoveryService {
    rpc GetTransports(TransportDiscoveryRequest) returns (TransportDiscoveryResponse);
}
